
# doit

## 基于UE的6G无线通信系统数字孪生交互框架 — 软件设计说明书（草稿）

**版本**：草稿

---

## 目录

- [1 引言](#1-引言)
- [2 总体设计](#2-总体设计)
- [3 系统出错处理设计](#3-系统出错处理设计)
- [4 Ray 集群的调度与通信](#4-ray-集群的调度与通信)
- [5 基站报错## 3 系统出错处理设计

### 3.1 错误处理原则

本系统采用分层错误处理机制，遵循"预防为主、快速响应、优雅降级、完整追溯"的设计理念，确保系统在各种异常情况下都能保持稳定运行。具体原则如下：

- **预防为主**：在数据输入、任务提交等环节实施严格的参数校验与类型检查，防止无效数据进入系统核心模块
- **快速响应**：建立多级日志记录与实时监控机制，确保异常发生时能及时捕获并通知相关模块
- **优雅降级**：当关键组件（如 Ray 集群、数据库）出现故障时，系统能自动切换到备用方案，避免整体崩溃
- **完整追溯**：通过结构化日志与错误码体系，记录完整的错误上下文信息，支持快速定位与问题复现

### 3.2 日志系统设计

#### 3.2.1 日志分级策略

系统采用五级日志分类机制，根据事件严重程度进行分级记录：

- **DEBUG 级别**：记录详细的程序执行流程与变量状态，主要用于开发调试阶段
- **INFO 级别**：记录系统正常运行时的关键节点，如任务启动、完成、资源分配等
- **WARNING 级别**：记录潜在问题或异常状态，如资源使用率超过阈值、请求响应时间过长等
- **ERROR 级别**：记录影响功能正常执行的错误，如网络连接失败、数据处理异常等
- **CRITICAL 级别**：记录导致系统崩溃或核心功能不可用的严重错误

#### 3.2.2 日志格式规范

系统统一采用结构化日志格式，便于日志检索、分析与可视化。每条日志包含以下核心字段：时间戳（精确到毫秒）、日志级别、模块名称、线程/进程标识、具体消息内容。对于异常日志，还需包含异常类型、堆栈跟踪等详细信息。

#### 3.2.3 日志文件管理

日志文件按功能模块分类存储，主要包括：系统总日志（`system.log`）、Ray 集群日志（`ray_cluster.log`）、仿真执行日志（`simulation.log`）、API 请求日志（`api.log`）以及错误专项日志（`error.log`）。

系统实施日志滚动策略，单个日志文件最大 50MB，超过限制后自动创建新文件，保留最近 10 个历史文件，既保证日志的完整性，又避免磁盘空间过度占用。

### 3.3 前端错误提示机制

#### 3.3.1 用户界面错误分级展示

前端根据错误的严重程度与影响范围，采用差异化的提示方式：

- **输入验证错误**：采用表单内联提示，实时反馈用户输入的问题（如"无人机ID不能为空"）
- **网络通信错误**：使用轻量级 Toast 通知，提示用户连接状态（如"连接服务器失败，请检查网络"）
- **业务逻辑错误**：通过模态对话框展示详细错误信息（如"仿真任务执行失败：Ray 集群不可用"）
- **系统严重错误**：显示全屏错误页面，提供错误码与联系方式，引导用户寻求技术支持

#### 3.3.2 统一错误码体系

系统定义五类错误码，每类占用一个千位段：

- **1xxx 系列**：参数错误（如 1001-参数缺失、1002-参数格式错误、1003-参数超出范围）
- **2xxx 系列**：资源错误（如 2001-场景不存在、2002-任务不存在、2003-资源不足）
- **3xxx 系列**：集群错误（如 3001-Ray集群连接失败、3002-集群资源不足、3003-任务执行超时）
- **4xxx 系列**：仿真错误（如 4001-仿真初始化失败、4002-仿真执行异常、4003-数据异常）
- **5xxx 系列**：系统错误（如 5001-内部服务器错误、5002-数据库连接失败、5003-文件系统错误）

该错误码体系在前后端统一使用，便于问题的快速定位与跨模块沟通。

### 3.4 Ray 集群异常处理

#### 3.4.1 集群连接异常处理

系统在连接 Ray 集群时实施重试机制，默认最多尝试 3 次连接。每次重试之间采用指数退避策略（第一次间隔 2 秒，第二次 4 秒，第三次 8 秒），避免对集群造成过大压力。若多次重试仍失败，系统将记录详细错误日志，并触发降级策略（切换到本地执行模式）或向管理员发送告警通知。

#### 3.4.2 任务执行异常捕获

在 Ray 分布式任务执行过程中，系统对可能出现的各类异常进行分类捕获与处理：参数验证错误返回错误码 1002，任务超时返回错误码 3003，未预期的系统异常返回错误码 5001。所有异常信息都通过统一的响应格式返回给调用方，包含状态标识（success/error）、错误码、错误描述等字段。

#### 3.4.3 集群资源检查机制

在提交仿真任务前，系统会主动检查 Ray 集群的可用资源（CPU 核心数、内存容量等）。通过调用 Ray 的资源查询接口，将当前可用资源与任务所需资源进行对比。若资源不足，系统拒绝任务提交并返回错误码 2003，同时向用户提示当前资源状态，避免任务排队等待或执行失败。

### 3.5 参数校验机制

#### 3.5.1 输入数据验证

系统使用数据模型库（如 Pydantic）定义严格的参数校验规则。对于无人机配置参数，校验内容包括：ID 长度限制（1-50 字符）、初始位置坐标范围（[-1000, 1000]）、高度非负、任务类型枚举值检查等。通过声明式的模型定义，自动完成参数的类型检查、边界验证与格式校验。

对于仿真任务请求，系统验证无人机数量范围（1-100），场景ID 存在性，运行时长合理性等。所有验证失败的情况都会返回详细的错误提示，指明具体哪个字段不符合要求。

#### 3.5.2 API 层统一校验

在 REST API 接口层，系统对所有请求数据进行统一拦截与验证。校验失败时返回 HTTP 400 状态码及详细错误信息，校验成功后再进入业务逻辑处理。这种分层验证机制既保证了数据质量，又避免了无效请求对后端资源的占用。

### 3.6 任务重试机制

#### 3.6.1 Ray 框架级重试

针对分布式任务执行中可能出现的瞬时故障（如网络抖动、节点临时不可达），系统配置 Ray 任务级别的自动重试。通过设置最大重试次数（如 3 次）和可重试异常类型（如超时异常、连接异常），确保偶发性故障不会导致任务失败。

#### 3.6.2 应用层重试策略

对于关键的业务操作（如任务提交、状态查询），系统实施应用层重试机制。采用指数退避算法控制重试间隔，避免频繁重试对系统造成压力。重试过程中记录每次尝试的结果，便于后续问题分析。达到最大重试次数后仍失败，则向上层抛出异常并记录详细日志。

### 3.7 检查点与容错恢复

#### 3.7.1 仿真状态检查点

系统在长时间运行的仿真任务中定期保存检查点（checkpoint），记录当前仿真步数、时间戳、所有 Agent 状态、网络拓扑等完整信息。检查点以序列化形式存储到本地文件系统，每个任务维护独立的检查点目录。为避免磁盘空间耗尽，系统仅保留最近 5 个检查点文件，自动清理过期数据。

#### 3.7.2 任务恢复策略

当仿真任务因异常中断后，系统支持从最近检查点恢复执行。恢复流程包括：加载检查点文件、重建 Agent 状态、重新连接 Ray 集群、继续从中断点执行。若未找到有效检查点，系统将从头开始执行任务。该机制有效提升了系统的容错能力，减少了因故障导致的计算资源浪费。

### 3.8 优雅降级策略

#### 3.8.1 分级降级方案

系统针对不同故障场景设计了差异化的降级策略：

- **Ray 集群不可用**：自动切换到本地单机执行模式，虽然性能有所下降但能保证核心功能可用
- **实时推送失败**：从 WebSocket 实时推送降级为 HTTP 轮询模式，增加网络开销但保证数据传输
- **可视化渲染性能不足**：降低数据更新频率（如从每秒 10 次降至每秒 2 次）或简化渲染细节
- **机器学习预测服务不可用**：使用基于规则的决策引擎或历史统计数据作为替代方案

#### 3.8.2 降级决策与恢复

系统通过健康检查机制持续监控各组件状态，当检测到异常时自动触发降级。降级过程中，系统会记录降级原因、时间与影响范围。同时，系统定期尝试恢复到正常模式，当检测到故障组件恢复正常后，自动切换回高性能模式，最大化利用系统资源。

### 3.9 系统监控与告警

#### 3.9.1 健康检查接口

系统提供 `/api/health` 接口供外部监控系统定期探测。该接口返回系统整体健康状态以及各核心组件（Ray 集群、数据库、文件系统等）的状态。若任何组件不健康，接口返回 HTTP 503 状态码，触发外部告警机制。

#### 3.9.2 多维度性能监控

系统实时监控以下关键指标：

- **性能指标**：API 接口平均响应时间、P95/P99 延迟、仿真任务执行时长、数据推送延迟等
- **资源指标**：服务器 CPU/内存使用率、Ray 集群各节点资源利用率、网络带宽占用等
- **业务指标**：当前活跃任务数、任务成功率/失败率、并发用户连接数等
- **错误指标**：各类错误发生频率、错误码分布、异常堆栈Top10 等

这些监控数据通过标准协议（如 Prometheus）暴露，可集成 Grafana 等可视化工具进行实时展示与历史趋势分析，支持运维人员及时发现并处理系统问题。

## 4 Ray 集群的调度与通信学习）](#5-基站报错预警机器学习)
- [6 应用](#6-应用)

---

## 1 引言

### 1.1 编写目的

本文档旨在详细阐述“基于UE的6G无线通信系统数字孪生交互框架”的软件设计方案。其主要目的是为项目开发团队提供一个清晰、统一的指导蓝图，确保各模块的设计和实现协调一致，并为开发、测试、维护与迭代提供参考。

### 1.2 背景说明

随着6G 技术的发展，其超高带宽、极低延迟与海量连接特性，为无人机（UAV）等 UE 在工业巡检、物流、应急通信等场景提供了更多可能。但真实环境中（如校园、城市）存在的信道干扰、基站覆盖与负载变化，会影响无人机通信质量与任务执行。

因此提出数字孪生系统，通过在虚拟空间精确复现无人机、基站与电磁环境，来模拟、预测与优化无人机行为与网络性能。本项目名称 `基于UE的6G无线通信系统数字孪生交互框架`，拟借助 `Ray` 框架构建可扩展的分布式数字孪生平台。

### 1.3 定义

| 术语 | 定义 |
| --- | --- |
| **数字孪生 (Digital Twin)** | 在虚拟空间中创建与物理实体对应的数字化模型，通过实时数据交互反映物理实体生命周期。 |
| **用户设备 (UE)** | User Equipment，指网络终端设备，本项目特指无人机（UAV）。 |
| **移动边缘计算 (MEC)** | 将计算与存储下沉到网络边缘，降低延迟并提升响应能力。 |
| **Ray** | 开源分布式计算框架，用于并行任务与 Actor 管理。 |
| **无人机代理 (Vehicle Agent)** | 仿真中代表真实无人机行为和通信的软件实体。 |
| **场景 (Scenario)** | 仿真环境配置集合（地图、基站布局、UE 初始状态、任务目标等）。 |

## 2 总体设计

### 2.1 需求规定

系统核心需求包括：环境建模、分布式仿真、UE 行为模拟、6G 通信模拟、数据可视化与交互，以及模块化与可扩展性。

### 2.2 运行环境

- 操作系统：Linux（建议 Ubuntu 20.04+）
- 后端：Python 3.10+、`Ray`、Flask / FastAPI
- 前端：HTML5、CSS3、JavaScript（ES6+）、Vue 或 React
- 相关库示例：`ray`, `numpy`, `pandas`, `matplotlib`, `websockets`

### 2.3 基本设计概念和处理流程

设计理念：仿真与现实分离，计算与交互分离。前端提交仿真任务至后端，后端将任务分解为 `Ray` 任务或 Actor 提交给集群并行执行，仿真数据通过 WebSocket 实时推送至前端进行可视化与交互。

主要流程：
- 场景配置（`droneOnCampus/src/frontend`）
- 任务提交（`droneOnCampus/src/backend/python/castray_backend.py`）
- 任务分发（`CastRay/ray_casting.py` 等）
- 分布式计算与状态更新（`CastRay/ray_cluster_discovery.py`, `vehicle_mec_agent.py`）
- 汇总、处理并通过 WebSocket 推送结果

### 2.4 结构设计

主要模块：
- 表现层：`droneOnCampus/src/frontend`, `diaplayRayCluster`
- 应用层：`droneOnCampus/src/backend/python/castray_backend.py`
- 核心计算层：`CastRay/main.py`, `CastRay/models.py`, `CastRay/ray_casting.py`, `CastRay/file_transfer.py`
- 集群管理：`CastRay/start_ray_cluster.py`, `CastRay/ray_cluster_discovery.py`

#### 功能映射（示例表）

| 功能需求 | 主要实现模块 |
| --- | --- |
| 环境建模 | `droneOnCampus/src/frontend`, `CastRay/models.py` |
| 分布式仿真 | `CastRay/ray_casting.py`, `ray` |
| UE 行为模拟 | `droneOnCampus/src/backend/python/vehicle_mec_agent.py` |
| 6G 通信模拟 | `CastRay/models.py`, `CastRay/ray_casting.py` |
| 数据可视化 | `droneOnCampus/src/frontend`, `diaplayRayCluster` |
| 任务管理 | `droneOnCampus/src/backend/python/castray_backend.py` |

### 2.5 接口设计（概要）

- 前端-后端：RESTful（如 `POST /api/simulation/start`）与 WebSocket（如 `ws://server/api/simulation/stream`）。
- 应用-计算：通过 `ray.remote()` 提交任务或创建 Actor。

### 2.6 核心 API 规范（REST / WebSocket 示例）

下面给出若干核心接口的示例（请求/响应 JSON、状态码与错误示例），作为前后端与仿真执行模块对接的最低实现契约。

1) 启动仿真任务 — POST /api/simulation/start

Request (application/json):

```json
{
	"scenario_id": "campus-01",
	"job_name": "patrol-morning",
	"drones": [
		{"id": "u1", "init_pos": [10.0, 20.0, 5.0], "mission": "patrol"},
		{"id": "u2", "init_pos": [15.0, 25.0, 5.0], "mission": "inspection"}
	],
	"network_params": {
		"band": "sub-THz",
		"tx_power_dbm": 23,
		"bandwidth_mhz": 100
	},
	"runtime": {"duration_s": 1800, "update_interval_s": 1}
}
```

Response (202 Accepted):

```json
{
	"job_id": "job-20251029-0001",
	"status": "accepted",
	"message": "simulation job accepted"
}
```

错误示例 (400 Bad Request)：参数缺失或非法

```json
{ "error": "missing field: drones" }
```

2) 查询仿真状态 — GET /api/simulation/status/{job_id}

Response (200 OK):

```json
{
	"job_id": "job-20251029-0001",
	"status": "running",   
	"started_at": "2025-10-29T09:00:00Z",
	"progress": {"elapsed_s": 120, "duration_s": 1800},
	"metrics": {"active_agents": 2}
}
```

3) 停止仿真任务 — POST /api/simulation/stop

Request:

```json
{ "job_id": "job-20251029-0001", "graceful": true }
```

Response (200 OK):

```json
{ "job_id": "job-20251029-0001", "status": "stopping" }
```

4) WebSocket 实时数据流 — ws://{host}/api/simulation/stream?job_id={job_id}

连接后，后端以 JSON 消息推送仿真状态、Agent 状态与 KPI。建议使用统一的消息 envelope：

示例消息 - 状态更新（type = "state_update")：

```json
{
	"type": "state_update",
	"job_id": "job-20251029-0001",
	"timestamp": 1698612345,
	"vehicles": [
		{"id":"u1","pos":[10.5,20.3,5.0],"vel":[0.1,0.0,0.0],"snr_db": -65.2},
		{"id":"u2","pos":[15.1,25.4,5.0],"snr_db": -70.4}
	],
	"kpi": {"avg_throughput_mbps": 12.3, "max_latency_ms": 45}
}
```

示例消息 - 事件/告警（type = "event")：

```json
{
	"type": "event",
	"level": "warning",
	"job_id": "job-20251029-0001",
	"timestamp": 1698612400,
	"message": "Vehicle u1 SNR below threshold (-80 dB)"
}
```

设计总结：
- 所有 REST 接口使用标准 HTTP 状态码（200/202/400/404/500）；错误响应包含统一字段 `{code, error, details}`。
- WebSocket 建议采用心跳/心跳应答机制（例如每 30s 发送 ping），并支持客户端通过 message 类型 `control` 发送控制命令（如请求更高频率的更新或修改 agent 参数）。
- 将接口契约写成可机读文档（OpenAPI / Swagger）以便前后端自动对齐与生成客户端。

## 3 系统出错处理设计

详见原文档；此处保留日志、前端提示、Ray 集群异常处理、参数校验、任务重试、检查点与优雅降级等机制的描述（已将相关文件名统一为反引号格式）。

## 4 Ray 集群的调度与通信

说明 `Ray` 在任务（Task）、Actor、对象存储（Object Store）与 gRPC 通信方面的使用模式，已在文中统一为标准术语与示例文件路径引用。

## 5 基站报错预警（机器学习）

保留并稍作精简：描述云-边协同、边缘轻量检测（如 LightGBM）、云端长序列模型（如 Transformer/FT-Transformer）与分级预警的思路。

## 6 应用

保留原有应用场景：网络规划、资源优化、应急通信保障、算法验证平台。
